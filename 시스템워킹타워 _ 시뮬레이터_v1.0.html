<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>íƒ€ì›Œ ì‹œë®¬ë ˆì´í„°</title>
    <style>
        body {
            margin: 0;
            font-family: 'Malgun Gothic', sans-serif;
            background: #1a1a1a;
            color: #fff;
            overflow: hidden;
        }
        
        .header-banner {
            background: #1976D2;
            color: white;
            padding: 10px 20px;
            text-align: center;
            font-size: 14px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            position: relative;
            z-index: 2000;
        }
        
        .header-banner a {
            color: #FFD700;
            text-decoration: none;
            font-weight: bold;
            margin-left: 10px;
        }
        
        .header-banner a:hover {
            text-decoration: underline;
        }
        
        #canvas-container {
            position: relative;
            height: calc(100vh - 40px);
        }
        
        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            max-width: 300px;
            z-index: 1000;
        }
        
        h2 {
            margin: 0 0 20px 0;
            font-size: 20px;
            color: #00ff88;
        }
        
        .control-group {
            margin-bottom: 15px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-size: 14px;
            color: #aaa;
        }
        
        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #333;
            outline: none;
            -webkit-appearance: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #00ff88;
            cursor: pointer;
        }
        
        .value-display {
            display: inline-block;
            color: #00ff88;
            font-weight: bold;
        }
        
        button {
            width: 100%;
            padding: 10px;
            margin-top: 10px;
            background: #00ff88;
            color: #000;
            border: none;
            border-radius: 5px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        button:hover {
            background: #00cc6a;
            transform: translateY(-2px);
        }
        
        .checkbox-group {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }
        
        input[type="checkbox"] {
            margin-right: 10px;
        }
        
        #info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 5px;
            backdrop-filter: blur(10px);
            font-size: 14px;
            max-width: 300px;
        }
        
        #dimensions {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 5px;
            backdrop-filter: blur(10px);
            font-size: 14px;
        }
        
        #canvas {
            width: 100%;
            height: 100%;
        }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            color: #00ff88;
        }
    </style>
</head>
<body>
    <div class="header-banner">
        ğŸ—ï¸ ê°€ì„¤íŒŒíŠ¸ë„ˆ íƒ€ì›Œ(ê³„ë‹¨íƒ‘) ì‹œë®¬ë ˆì´í„° | 
        <a href="https://gaseolpartner.com" target="_blank">í™ˆí˜ì´ì§€ ë°©ë¬¸</a> | 
        Â© 2025 ê°€ì„¤íŒŒíŠ¸ë„ˆ
    </div>
    
    <div id="canvas-container">
        <div id="loading">ë¡œë”© ì¤‘...</div>
        
        <div id="controls" style="display: none;">
            <h2>íƒ€ì›Œ ì‹œë®¬ë ˆì´í„°</h2>

            
            <div class="control-group">
                <label>ì¸µìˆ˜: <span class="value-display" id="floorsValue">4</span></label>
                <input type="range" id="floors" min="1" max="10" value="4" step="1">
            </div>
            
            <div class="checkbox-group">
                <input type="checkbox" id="showStairs" checked>
                <label for="showStairs">ì•ˆì „ê³„ë‹¨ í‘œì‹œ</label>
            </div>
            
            <div class="checkbox-group">
                <input type="checkbox" id="showPlatforms" checked>
                <label for="showPlatforms">ë°œíŒ í‘œì‹œ</label>
            </div>
            
            <div class="checkbox-group">
                <input type="checkbox" id="showRails" checked>
                <label for="showRails">ì•ˆì „ë‚œê°„ í‘œì‹œ</label>
            </div>
            
            <div class="checkbox-group">
                <input type="checkbox" id="showBraces" checked>
                <label for="showBraces">ê°€ìƒˆ í‘œì‹œ</label>
            </div>
            
            <button onclick="generateScaffold()">ë¹„ê³„ ì¬ìƒì„±</button>
            <button onclick="rotateCamera()">ìë™ íšŒì „ í† ê¸€</button>
        </div>
        
        <div id="dimensions" style="display: none;">
            <strong>í˜„ì¬ ì¹˜ìˆ˜:</strong><br>
            ê°€ë¡œ: <span id="totalWidth">5487</span>mm<br>
            ì„¸ë¡œ: <span id="totalDepth">3658</span>mm<br>
            ë†’ì´: <span id="totalHeight">7600</span>mm
        </div>
        
        <div id="info" style="display: none;">
            <strong>ì¡°ì‘ë²•:</strong><br>
            â€¢ ë§ˆìš°ìŠ¤ ë“œë˜ê·¸: ì¹´ë©”ë¼ íšŒì „<br>
            â€¢ ìŠ¤í¬ë¡¤: í™•ëŒ€/ì¶•ì†Œ<br>
            â€¢ ìš°í´ë¦­ ë“œë˜ê·¸: ì¹´ë©”ë¼ ì´ë™<br><br>
            <strong>ê·œê²©:</strong><br>
            â€¢ ë² ì´: 1829mm Ã— 1829mm<br>
            â€¢ ì¸µê³ : 1900mm
        </div>
        
        <canvas id="canvas"></canvas>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script>
        // ì „ì—­ ë³€ìˆ˜ ì„ ì–¸
        let scene, camera, renderer, controls;
        let scaffoldGroup, stairsGroup, platformsGroup, railsGroup, braceGroup;
        let autoRotate = false;

        
        // ì‹¤ì œ ë¹„ê³„ ê·œê²© (mm ë‹¨ìœ„ë¥¼ më¡œ ë³€í™˜)
        const DIMENSIONS = {
            bayWidth: 1.829,      // 1829mm
            bayDepth: 1.829,      // 1829mm
            floorHeight: 1.9,     // 1900mm
            pipeRadius: 0.025,    // 50mm ì§ê²½
            platformThickness: 0.05,
            stairWidth: 0.61,     // 610mm
            railHeight: 1.0,      // 1000mm
            bracketWidth: 0.914,  // 914mm (ì•ˆì „ë°œíŒ ê·œê²©)
            bracketDepth: 0.61    // 610mm
        };
        
        // ì´ˆê¸°í™” í•¨ìˆ˜
        function init() {
            console.log('Initializing scene...');
            
            // Scene ìƒì„±
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a0a);
            scene.fog = new THREE.Fog(0x0a0a0a, 50, 200);
            
            // Camera ìƒì„±
            camera = new THREE.PerspectiveCamera(
                75, 
                window.innerWidth / window.innerHeight, 
                0.1, 
                1000
            );
            camera.position.set(15, 12, 15);
            
            // Renderer ìƒì„±
            renderer = new THREE.WebGLRenderer({ 
                canvas: document.getElementById('canvas'),
                antialias: true 
            });
            const container = document.getElementById('canvas-container');
            renderer.setSize(window.innerWidth, container.clientHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            
            // OrbitControls ì„¤ì •
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = false;
            controls.minDistance = 5;
            controls.maxDistance = 50;
            controls.maxPolarAngle = Math.PI / 2;
            controls.target.set(0, 5, 0);
            
            // ì¡°ëª… ì„¤ì •
            setupLights();
            
            // ë°”ë‹¥ ìƒì„±
            createGround();
            
            // ì´ˆê¸° ë¹„ê³„ ìƒì„±
            generateScaffold();
            
            // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì„¤ì •
            setupEventListeners();
            
            // UI í‘œì‹œ
            document.getElementById('loading').style.display = 'none';
            document.getElementById('controls').style.display = 'block';
            document.getElementById('dimensions').style.display = 'block';
            document.getElementById('info').style.display = 'block';
            
            // ì• ë‹ˆë©”ì´ì…˜ ì‹œì‘
            animate();
        }
        
        // ì¡°ëª… ì„¤ì •
        function setupLights() {
            // í™˜ê²½ê´‘
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambientLight);
            
            // ë°©í–¥ê´‘
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(50, 100, 50);
            directionalLight.castShadow = true;
            directionalLight.shadow.camera.left = -30;
            directionalLight.shadow.camera.right = 30;
            directionalLight.shadow.camera.top = 30;
            directionalLight.shadow.camera.bottom = -30;
            directionalLight.shadow.mapSize.width = 4096;
            directionalLight.shadow.mapSize.height = 4096;
            scene.add(directionalLight);
            
            // í¬ì¸íŠ¸ ë¼ì´íŠ¸
            const pointLight = new THREE.PointLight(0xffffff, 0.3);
            pointLight.position.set(-20, 20, -20);
            scene.add(pointLight);
        }
        
        // ë°”ë‹¥ ìƒì„±
        function createGround() {
            // ë°”ë‹¥ ë©”ì‹œ
            const groundGeometry = new THREE.PlaneGeometry(100, 100);
            const groundMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x222222,
                roughness: 0.9
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);
            
            // ê·¸ë¦¬ë“œ
            const gridHelper = new THREE.GridHelper(100, 50, 0x444444, 0x333333);
            scene.add(gridHelper);
        }
        
        // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì„¤ì •
        function setupEventListeners() {
            window.addEventListener('resize', onWindowResize);
            
            document.getElementById('floors').addEventListener('input', updateValues);
        }
        
        // ë¹„ê³„ ìƒì„± í•¨ìˆ˜
        function generateScaffold() {
            console.log('Generating scaffold...');
            
            // ê¸°ì¡´ ê·¸ë£¹ ì œê±°
            if (scaffoldGroup) scene.remove(scaffoldGroup);
            if (stairsGroup) scene.remove(stairsGroup);
            if (platformsGroup) scene.remove(platformsGroup);
            if (railsGroup) scene.remove(railsGroup);
            if (braceGroup) scene.remove(braceGroup);
            
            // ìƒˆ ê·¸ë£¹ ìƒì„±
            scaffoldGroup = new THREE.Group();
            stairsGroup = new THREE.Group();
            platformsGroup = new THREE.Group();
            railsGroup = new THREE.Group();
            braceGroup = new THREE.Group();
            
            // ìŠ¬ë¼ì´ë” ê°’ ê°€ì ¸ì˜¤ê¸°
            const width = 3;  // ê³ ì •ê°’
            const depth = 2;  // ê³ ì •ê°’
            const floors = parseInt(document.getElementById('floors').value);
            
            // ì¹˜ìˆ˜ ì—…ë°ì´íŠ¸
            updateDimensions(width, depth, floors);
            
            // ì‹œìŠ¤í…œ ë¹„ê³„ ìƒì„±
            createVerticalPosts(width, depth, floors);
            createHorizontalLedgers(width, depth, floors);
            
            if (document.getElementById('showBraces').checked) {
                createBraces(width, depth, floors);
            }
            
            if (document.getElementById('showPlatforms').checked) {
                createPlatforms(width, depth, floors);
            }
            
            if (document.getElementById('showStairs').checked) {
                createExternalStairTower(width, depth, floors);
            }
            
            if (document.getElementById('showRails').checked) {
                createSafetyRails(width, depth, floors);
            }
            
            // Sceneì— ì¶”ê°€
            scene.add(scaffoldGroup);
            scene.add(stairsGroup);
            scene.add(platformsGroup);
            scene.add(railsGroup);
            scene.add(braceGroup);
        }
        
        // ìˆ˜ì§ ê¸°ë‘¥ ìƒì„±
        function createVerticalPosts(width, depth, floors) {
            const { bayWidth, bayDepth, floorHeight, pipeRadius } = DIMENSIONS;
            
            const verticalPipeMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x999999,
                metalness: 0.8,
                roughness: 0.2
            });
            
            const verticalGeometry = new THREE.CylinderGeometry(
                pipeRadius, 
                pipeRadius, 
                floorHeight
            );
            
            for (let x = 0; x <= width; x++) {
                for (let z = 0; z <= depth; z++) {
                    for (let y = 0; y < floors; y++) {
                        const pipe = new THREE.Mesh(verticalGeometry, verticalPipeMaterial);
                        pipe.position.set(
                            x * bayWidth - (width * bayWidth) / 2,
                            y * floorHeight + floorHeight / 2,
                            z * bayDepth - (depth * bayDepth) / 2
                        );
                        pipe.castShadow = true;
                        pipe.receiveShadow = true;
                        scaffoldGroup.add(pipe);
                    }
                }
            }
        }
        
        // ìˆ˜í‰ ì¥ì„  ìƒì„±
        function createHorizontalLedgers(width, depth, floors) {
            const { bayWidth, bayDepth, floorHeight, pipeRadius } = DIMENSIONS;
            
            const horizontalPipeMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xaaaaaa,
                metalness: 0.8,
                roughness: 0.2
            });
            
            const ledgerXGeometry = new THREE.CylinderGeometry(
                pipeRadius * 0.9, 
                pipeRadius * 0.9, 
                bayWidth
            );
            const ledgerZGeometry = new THREE.CylinderGeometry(
                pipeRadius * 0.9, 
                pipeRadius * 0.9, 
                bayDepth
            );
            
            for (let y = 0; y <= floors; y++) {
                // Xë°©í–¥ ì¥ì„ 
                for (let x = 0; x < width; x++) {
                    for (let z = 0; z <= depth; z++) {
                        const pipe = new THREE.Mesh(ledgerXGeometry, horizontalPipeMaterial);
                        pipe.rotation.z = Math.PI / 2;
                        pipe.position.set(
                            x * bayWidth + bayWidth / 2 - (width * bayWidth) / 2,
                            y * floorHeight,
                            z * bayDepth - (depth * bayDepth) / 2
                        );
                        pipe.castShadow = true;
                        scaffoldGroup.add(pipe);
                        
                        // ì¤‘ê°„ ì¥ì„ 
                        if (y < floors) {
                            const midPipe = new THREE.Mesh(ledgerXGeometry, horizontalPipeMaterial);
                            midPipe.rotation.z = Math.PI / 2;
                            midPipe.position.set(
                                x * bayWidth + bayWidth / 2 - (width * bayWidth) / 2,
                                y * floorHeight + floorHeight * 0.5,
                                z * bayDepth - (depth * bayDepth) / 2
                            );
                            scaffoldGroup.add(midPipe);
                        }
                    }
                }
                
                // Zë°©í–¥ ì¥ì„ 
                for (let x = 0; x <= width; x++) {
                    for (let z = 0; z < depth; z++) {
                        const pipe = new THREE.Mesh(ledgerZGeometry, horizontalPipeMaterial);
                        pipe.rotation.x = Math.PI / 2;
                        pipe.position.set(
                            x * bayWidth - (width * bayWidth) / 2,
                            y * floorHeight,
                            z * bayDepth + bayDepth / 2 - (depth * bayDepth) / 2
                        );
                        pipe.castShadow = true;
                        scaffoldGroup.add(pipe);
                    }
                }
            }
        }
        
        // ê°€ìƒˆ ìƒì„±
        function createBraces(width, depth, floors) {
            const { bayWidth, bayDepth, floorHeight, pipeRadius } = DIMENSIONS;
            
            const braceMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x666666,
                metalness: 0.7,
                roughness: 0.3
            });
            
            const braceLength = Math.sqrt(bayWidth * bayWidth + floorHeight * floorHeight);
            const braceGeometry = new THREE.CylinderGeometry(
                pipeRadius * 0.8, 
                pipeRadius * 0.8, 
                braceLength
            );
            
            // ì „ë©´ ê°€ìƒˆ
            for (let x = 0; x < width; x++) {
                for (let y = 0; y < floors; y++) {
                    if (x % 2 === 0 || width === 1) {
                        const angle = Math.atan2(floorHeight, bayWidth);
                        
                        const brace1 = new THREE.Mesh(braceGeometry, braceMaterial);
                        brace1.position.set(
                            x * bayWidth + bayWidth / 2 - (width * bayWidth) / 2,
                            y * floorHeight + floorHeight / 2,
                            -(depth * bayDepth) / 2
                        );
                        brace1.rotation.z = angle;
                        braceGroup.add(brace1);
                        
                        const brace2 = new THREE.Mesh(braceGeometry, braceMaterial);
                        brace2.position.set(
                            x * bayWidth + bayWidth / 2 - (width * bayWidth) / 2,
                            y * floorHeight + floorHeight / 2,
                            -(depth * bayDepth) / 2
                        );
                        brace2.rotation.z = -angle;
                        braceGroup.add(brace2);
                    }
                }
            }
        }
        
        // ì‘ì—… ë°œíŒ ìƒì„± (3x2 ê³ ì •)
        function createPlatforms(width, depth, floors) {
            const { bayWidth, bayDepth, floorHeight } = DIMENSIONS;
            
            const platformMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x555555,
                metalness: 0.5,
                roughness: 0.5
            });
            
            const platformGeometry = new THREE.BoxGeometry(
                bayWidth - 0.05, 
                DIMENSIONS.platformThickness, 
                DIMENSIONS.bracketWidth
            );
            
            // 3x2 ê³ ì •ì´ë¯€ë¡œ ê³„ë‹¨ì€ í•­ìƒ ì¤‘ê°„ ë² ì´(1,0)ì— ìœ„ì¹˜
            const stairBayX = 1;
            const stairBayZ = 0;
            
            for (let y = 1; y <= floors; y++) {
                for (let x = 0; x < width; x++) {
                    for (let z = 0; z < depth; z++) {
                        // ê³„ë‹¨ì´ í‘œì‹œë˜ê³  ìˆê³ , ê³„ë‹¨ ë² ì´ì¸ ê²½ìš° ë°œíŒ ìƒëµ
                        if (document.getElementById('showStairs').checked && 
                            x === stairBayX && z === stairBayZ) {
                            continue;
                        }
                        
                        const platform = new THREE.Mesh(platformGeometry, platformMaterial);
                        platform.position.set(
                            x * bayWidth + bayWidth / 2 - (width * bayWidth) / 2,
                            y * floorHeight - floorHeight / 2,
                            z * bayDepth + bayDepth / 2 - (depth * bayDepth) / 2
                        );
                        platform.castShadow = true;
                        platform.receiveShadow = true;
                        platformsGroup.add(platform);
                    }
                }
            }
        }
        
        // ë‚´ë¶€ í†µí•©í˜• ê³„ë‹¨ ìƒì„± (3x2 ê³ ì • êµ¬ì¡°)
        function createExternalStairTower(width, depth, floors) {
            const { bayWidth, bayDepth, floorHeight } = DIMENSIONS;
            
            // 3x2 ê³ ì •ì´ë¯€ë¡œ ê³„ë‹¨ì€ í•­ìƒ ì¤‘ê°„ ë² ì´(ì¸ë±ìŠ¤ 1)ì— ì„¤ì¹˜
            const stairBayX = 1;  // ì¤‘ê°„ ë² ì´
            const stairBayZ = 0;  // ì•ìª½ ë² ì´
            
            const stairWidth = 0.61;
            const stepHeight = 0.19;
            const stepDepth = 0.26;
            const stepsPerFloor = 10;  // í•œ ì¸µë‹¹ ì´ 10ë‹¨
            
            // ì¬ì§ˆ ì •ì˜
            const stepMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x444444,
                metalness: 0.3,
                roughness: 0.7
            });
            
            const railMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xffaa00,
                metalness: 0.8,
                roughness: 0.2
            });
            
            // ê³„ë‹¨ ë² ì´ì˜ ì¤‘ì‹¬ ì¢Œí‘œ
            const stairCenterX = stairBayX * bayWidth + bayWidth / 2 - (width * bayWidth) / 2;
            const stairCenterZ = stairBayZ * bayDepth + bayDepth / 2 - (depth * bayDepth) / 2;
            
            // ê° ì¸µì— ëŒ€í•œ ê³„ë‹¨ ìƒì„±
            for (let floor = 0; floor < floors; floor++) {
                // ë§ˆì§€ë§‰ ì¸µì€ ê³„ë‹¨ ëŒ€ì‹  ì‚¬ë‹¤ë¦¬ë‚˜ ê°„ë‹¨í•œ ì ‘ê·¼ë¡œë§Œ ì„¤ì¹˜
                if (floor === floors - 1) {
                    // ë§ˆì§€ë§‰ ì¸µ ì ‘ê·¼ìš© ì§§ì€ ê³„ë‹¨ (5ë‹¨ë§Œ)
                    const lastFloorSteps = 5;
                    for (let step = 0; step < lastFloorSteps; step++) {
                        const stepGeometry = new THREE.BoxGeometry(stepDepth, 0.03, stairWidth);
                        const stepMesh = new THREE.Mesh(stepGeometry, stepMaterial);
                        
                        // ì¤‘ì•™ì—ì„œ ì‹œì‘í•˜ëŠ” ì§§ì€ ê³„ë‹¨
                        stepMesh.position.set(
                            stairCenterX - bayWidth/4 + (step + 1) * (bayWidth/2 / lastFloorSteps),
                            floor * floorHeight + step * stepHeight + stepHeight / 2,
                            stairCenterZ - bayDepth/3  // í•­ìƒ ì•ìª½
                        );
                        
                        stepMesh.castShadow = true;
                        stepMesh.receiveShadow = true;
                        stairsGroup.add(stepMesh);
                        
                        // ë¯¸ë„ëŸ¼ ë°©ì§€ íŒ¨í„´
                        const patternGeometry = new THREE.BoxGeometry(stepDepth * 0.8, 0.002, stairWidth * 0.9);
                        const patternMaterial = new THREE.MeshStandardMaterial({ 
                            color: 0x222222,
                            metalness: 0.1,
                            roughness: 0.9
                        });
                        const pattern = new THREE.Mesh(patternGeometry, patternMaterial);
                        pattern.position.copy(stepMesh.position);
                        pattern.position.y += 0.02;
                        stairsGroup.add(pattern);
                    }
                    
                    // ë§ˆì§€ë§‰ ì¸µ ë‚œê°„ (ê°„ë‹¨í•˜ê²Œ)
                    const railHeight = 0.9;
                    const railGeometry = new THREE.CylinderGeometry(0.02, 0.02, railHeight);
                    
                    for (let i = 0; i <= lastFloorSteps; i += 2) {
                        const xPos = stairCenterX - bayWidth/4 + i * (bayWidth/2 / lastFloorSteps);
                        const zPos = stairCenterZ - bayDepth/3;
                        
                        // ì•ìª½ ë‚œê°„
                        const frontRail = new THREE.Mesh(railGeometry, railMaterial);
                        frontRail.position.set(
                            xPos,
                            floor * floorHeight + i * stepHeight + railHeight/2,
                            zPos - stairWidth/2 - 0.1
                        );
                        stairsGroup.add(frontRail);
                        
                        // ë’¤ìª½ ë‚œê°„
                        const backRail = new THREE.Mesh(railGeometry, railMaterial);
                        backRail.position.set(
                            xPos,
                            floor * floorHeight + i * stepHeight + railHeight/2,
                            zPos + stairWidth/2 + 0.1
                        );
                        stairsGroup.add(backRail);
                    }
                    
                    continue;  // ë§ˆì§€ë§‰ ì¸µì€ ì—¬ê¸°ì„œ ë
                }
                
                // ì¼ë°˜ ì¸µ ê³„ë‹¨ (1ì¸µë¶€í„° ë§ˆì§€ë§‰-1ì¸µê¹Œì§€)
                // 3x2 êµ¬ì¡°ì—ì„œ ì•ë’¤ë¡œ ì „í™˜í•˜ë©° ì¢Œìš° ì´ë™
                const direction = floor % 4;  // 0: ì™¼ìª½(ì•), 1: ì˜¤ë¥¸ìª½(ì•), 2: ì™¼ìª½(ë’¤), 3: ì˜¤ë¥¸ìª½(ë’¤)
                
                for (let step = 0; step < stepsPerFloor; step++) {
                    const stepGeometry = new THREE.BoxGeometry(stepDepth, 0.03, stairWidth);
                    const stepMesh = new THREE.Mesh(stepGeometry, stepMaterial);
                    
                    let xPos, zPos;
                    
                    if (direction === 0 || direction === 2) {
                        // ì™¼ìª½ìœ¼ë¡œ ì´ë™
                        xPos = stairCenterX + bayWidth/2 - (step + 1) * (bayWidth / stepsPerFloor);
                        
                        if (direction === 0) {
                            zPos = stairCenterZ - bayDepth/3;  // ì•ìª½
                        } else {
                            zPos = stairCenterZ + bayDepth/3;  // ë’¤ìª½
                        }
                    } else {
                        // ì˜¤ë¥¸ìª½ìœ¼ë¡œ ì´ë™
                        xPos = stairCenterX - bayWidth/2 + (step + 1) * (bayWidth / stepsPerFloor);
                        
                        if (direction === 1) {
                            zPos = stairCenterZ - bayDepth/3;  // ì•ìª½
                        } else {
                            zPos = stairCenterZ + bayDepth/3;  // ë’¤ìª½
                        }
                    }
                    
                    stepMesh.position.set(
                        xPos,
                        floor * floorHeight + step * stepHeight + stepHeight / 2,
                        zPos
                    );
                    
                    stepMesh.castShadow = true;
                    stepMesh.receiveShadow = true;
                    stairsGroup.add(stepMesh);
                    
                    // ê³„ë‹¨ í‘œë©´ ë¯¸ë„ëŸ¼ ë°©ì§€ íŒ¨í„´
                    const patternGeometry = new THREE.BoxGeometry(stepDepth * 0.8, 0.002, stairWidth * 0.9);
                    const patternMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0x222222,
                        metalness: 0.1,
                        roughness: 0.9
                    });
                    const pattern = new THREE.Mesh(patternGeometry, patternMaterial);
                    pattern.position.copy(stepMesh.position);
                    pattern.position.y += 0.02;
                    stairsGroup.add(pattern);
                }
                
                // ê³„ë‹¨ ë‚œê°„
                const railHeight = 0.9;
                const railGeometry = new THREE.CylinderGeometry(0.02, 0.02, railHeight);
                
                // ë‚œê°„ ê¸°ë‘¥ ì„¤ì¹˜ (3ë‹¨ë§ˆë‹¤)
                for (let step = 0; step <= stepsPerFloor; step += 3) {
                    let xPos, zPosRail;
                    
                    if (direction === 0 || direction === 2) {
                        xPos = stairCenterX + bayWidth/2 - step * (bayWidth / stepsPerFloor);
                        
                        if (direction === 0) {
                            zPosRail = stairCenterZ - bayDepth/3;
                        } else {
                            zPosRail = stairCenterZ + bayDepth/3;
                        }
                    } else {
                        xPos = stairCenterX - bayWidth/2 + step * (bayWidth / stepsPerFloor);
                        
                        if (direction === 1) {
                            zPosRail = stairCenterZ - bayDepth/3;
                        } else {
                            zPosRail = stairCenterZ + bayDepth/3;
                        }
                    }
                    
                    // ì•ìª½ ë‚œê°„
                    const frontRail = new THREE.Mesh(railGeometry, railMaterial);
                    frontRail.position.set(
                        xPos,
                        floor * floorHeight + step * stepHeight + railHeight/2,
                        zPosRail - stairWidth/2 - 0.1
                    );
                    stairsGroup.add(frontRail);
                    
                    // ë’¤ìª½ ë‚œê°„
                    const backRail = new THREE.Mesh(railGeometry, railMaterial);
                    backRail.position.set(
                        xPos,
                        floor * floorHeight + step * stepHeight + railHeight/2,
                        zPosRail + stairWidth/2 + 0.1
                    );
                    stairsGroup.add(backRail);
                }
                
                // í•¸ë“œë ˆì¼ (ê²½ì‚¬ì§„ ì†ì¡ì´)
                const handrailRadius = 0.025;
                const handrailLength = Math.sqrt(
                    bayWidth * bayWidth + 
                    (stepsPerFloor * stepHeight) * (stepsPerFloor * stepHeight)
                );
                const handrailGeometry = new THREE.CylinderGeometry(
                    handrailRadius, 
                    handrailRadius, 
                    handrailLength
                );
                
                const angle = Math.atan2(stepsPerFloor * stepHeight, bayWidth);
                
                // ì–‘ìª½ í•¸ë“œë ˆì¼
                for (let side = 0; side < 2; side++) {
                    const handrail = new THREE.Mesh(handrailGeometry, railMaterial);
                    let zOffset;
                    
                    if (direction === 0 || direction === 2) {
                        if (direction === 0) {
                            zOffset = stairCenterZ - bayDepth/3 + (side === 0 ? -stairWidth/2 - 0.1 : stairWidth/2 + 0.1);
                        } else {
                            zOffset = stairCenterZ + bayDepth/3 + (side === 0 ? -stairWidth/2 - 0.1 : stairWidth/2 + 0.1);
                        }
                        
                        handrail.position.set(
                            stairCenterX,
                            floor * floorHeight + (stepsPerFloor * stepHeight)/2 + railHeight,
                            zOffset
                        );
                        handrail.rotation.z = angle;
                    } else {
                        if (direction === 1) {
                            zOffset = stairCenterZ - bayDepth/3 + (side === 0 ? -stairWidth/2 - 0.1 : stairWidth/2 + 0.1);
                        } else {
                            zOffset = stairCenterZ + bayDepth/3 + (side === 0 ? -stairWidth/2 - 0.1 : stairWidth/2 + 0.1);
                        }
                        
                        handrail.position.set(
                            stairCenterX,
                            floor * floorHeight + (stepsPerFloor * stepHeight)/2 + railHeight,
                            zOffset
                        );
                        handrail.rotation.z = -angle;
                    }
                    
                    stairsGroup.add(handrail);
                }
            }
        }
        
        // ì•ˆì „ ë‚œê°„ ìƒì„±
        function createSafetyRails(width, depth, floors) {
            const { bayWidth, bayDepth, floorHeight, railHeight } = DIMENSIONS;
            
            const railMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xffaa00,
                metalness: 0.8,
                roughness: 0.2
            });
            
            const railGeometry = new THREE.CylinderGeometry(0.02, 0.02, railHeight);
            const topRailGeometry = new THREE.CylinderGeometry(0.025, 0.025, bayWidth);
            
            for (let y = 1; y <= floors; y++) {
                // ì™¸ê³½ ë‚œê°„ ê¸°ë‘¥ - í›„ë©´ë§Œ (ê³„ë‹¨ ë°˜ëŒ€í¸)
                for (let x = 0; x <= width; x++) {
                    // í›„ë©´
                    const post = new THREE.Mesh(railGeometry, railMaterial);
                    post.position.set(
                        x * bayWidth - (width * bayWidth) / 2,
                        y * floorHeight - floorHeight / 2 + railHeight / 2,
                        (depth * bayDepth) / 2
                    );
                    railsGroup.add(post);
                }
                
                // ìƒë¶€ ë‚œê°„ - í›„ë©´ë§Œ
                for (let x = 0; x < width; x++) {
                    const topRail = new THREE.Mesh(topRailGeometry, railMaterial);
                    topRail.rotation.z = Math.PI / 2;
                    topRail.position.set(
                        x * bayWidth + bayWidth / 2 - (width * bayWidth) / 2,
                        y * floorHeight - floorHeight / 2 + railHeight,
                        (depth * bayDepth) / 2
                    );
                    railsGroup.add(topRail);
                    
                    // ì¤‘ê°„ ë‚œê°„
                    const midRail = new THREE.Mesh(topRailGeometry, railMaterial);
                    midRail.rotation.z = Math.PI / 2;
                    midRail.position.set(
                        x * bayWidth + bayWidth / 2 - (width * bayWidth) / 2,
                        y * floorHeight - floorHeight / 2 + railHeight / 2,
                        (depth * bayDepth) / 2
                    );
                    railsGroup.add(midRail);
                }
                
                // ë°œëë§‰ì´íŒ - í›„ë©´ë§Œ
                const toeBoardGeometry = new THREE.BoxGeometry(bayWidth, 0.15, 0.02);
                const toeBoardMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xcc6600,
                    metalness: 0.3,
                    roughness: 0.7
                });
                
                for (let x = 0; x < width; x++) {
                    const toeBoard = new THREE.Mesh(toeBoardGeometry, toeBoardMaterial);
                    toeBoard.position.set(
                        x * bayWidth + bayWidth / 2 - (width * bayWidth) / 2,
                        y * floorHeight - floorHeight / 2 + 0.075,
                        (depth * bayDepth) / 2
                    );
                    railsGroup.add(toeBoard);
                }
            }
        }
        
        // ì¹˜ìˆ˜ ì—…ë°ì´íŠ¸
        function updateDimensions(width, depth, floors) {
            const totalWidth = Math.round(width * DIMENSIONS.bayWidth * 1000);
            const totalDepth = Math.round(depth * DIMENSIONS.bayDepth * 1000);
            const totalHeight = Math.round(floors * DIMENSIONS.floorHeight * 1000);
            
            document.getElementById('totalWidth').textContent = totalWidth;
            document.getElementById('totalDepth').textContent = totalDepth;
            document.getElementById('totalHeight').textContent = totalHeight;
        }
        
        // ìŠ¬ë¼ì´ë” ê°’ ì—…ë°ì´íŠ¸
        function updateValues() {
            document.getElementById('floorsValue').textContent = document.getElementById('floors').value;
        }
        
        // ì¹´ë©”ë¼ ìë™ íšŒì „ í† ê¸€
        function rotateCamera() {
            autoRotate = !autoRotate;
            if (controls) {
                controls.autoRotate = autoRotate;
                controls.autoRotateSpeed = 2.0;
            }
        }
        
        // ìœˆë„ìš° ë¦¬ì‚¬ì´ì¦ˆ í•¸ë“¤ëŸ¬
        function onWindowResize() {
            const container = document.getElementById('canvas-container');
            camera.aspect = window.innerWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, container.clientHeight);
        }
        
        // ì• ë‹ˆë©”ì´ì…˜ ë£¨í”„
        function animate() {
            requestAnimationFrame(animate);
            
            // Controls ì—…ë°ì´íŠ¸
            if (controls) {
                controls.update();
            }
            
            // ì²´í¬ë°•ìŠ¤ì— ë”°ë¥¸ ê°€ì‹œì„± ì—…ë°ì´íŠ¸
            if (stairsGroup) {
                stairsGroup.visible = document.getElementById('showStairs').checked;
            }
            if (platformsGroup) {
                platformsGroup.visible = document.getElementById('showPlatforms').checked;
            }
            if (railsGroup) {
                railsGroup.visible = document.getElementById('showRails').checked;
            }
            if (braceGroup) {
                braceGroup.visible = document.getElementById('showBraces').checked;
            }
            
            // ë Œë”ë§
            renderer.render(scene, camera);
        }
        
        // í˜ì´ì§€ ë¡œë“œ ì‹œ ì´ˆê¸°í™”
        window.addEventListener('load', init);
    </script>
</body>
</html>